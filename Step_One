import atexit
from time import clock
from functools import reduce


def seconds_to_str(t):
    return "%d:%02d:%02d.%03d" % \
           reduce(lambda ll, b: divmod(ll[0], b) + ll[1:],
                  [(t * 1000,), 1000, 60, 60])


line = "=" * 40


def log(s, elapsed=None):
    print(line)
    print(seconds_to_str(clock()), '-', s)
    if elapsed:
        print("Elapsed time:", elapsed)
    print(line)
    print()


def endlog():
    end = clock()
    elapsed = end - start
    log("End Program", seconds_to_str(elapsed))


def now():
    return seconds_to_str(clock())


start = clock()
atexit.register(endlog)
log("Start Program")

import pandas as pd
import numpy as np
from mpi4py import MPI
comm = MPI.COMM_WORLD
rank = comm.Get_rank()
from DispersionRelationDeterminantFullConductivityZeff import Dispersion
#VERSION 1 run the following: srun -N 1 -n 32 -t 01:00:00 -p development -J GKIMP ibrun netCDF4 python3 ./<file>.py
# this code can most likely be optimized to run on all arrays universally

filename='MTM_dispersion_n_scanp169509.04218_465'


def Dispersion_calc(filename):
    rank    
    gamma_complex_temp=0                   
    gamma_complex=[]  
    data=pd.read_csv(filename+'.csv')  	#data is a dataframe.                          #code will run on all procs unless specified, careful.       
 
    nu=data['nu']
    nx=len(nu)
    zeff=data['zeff'][0]
  
    eta=data['eta']

    shat=data['shat']

    beta=data['beta']
  
    ky=data['ky']
    
    mu=data['mu']
   
    xstar=data['xstar'][0]
    
    ModIndex=data['ModIndex'][0]
     
    ##if rank == 0:                               #more of a test than anything. Causes clutter, off by default.
        ##for i in range(nx):          
            ##print(nu, eta, shat, beta, ky, mu, zeff, ModIndex, xstar)
            
    if size >= nx:        
        for i in range(nx):
            if rank == i:     
                gamma_complex_temp=Dispersion(nu[i], eta[i], shat[i], beta[i], ky[i], mu[i], zeff, ModIndex, xstar) 
                gamma_complex.append(gamma_complex_temp)
    else:
        for i in range(size):
            if (rank) == i:
                m = nx%size             #remainder
                n = nx//size            #number of times size can fit evenly into nx
                for x in range(n):
                    if x == 0:
                        gamma_complex_temp2=Dispersion(nu[(size*x)+i], eta[(size*x)+i], shat[(size*x)+i], beta[(size*x)+i], ky[(size*x)+i], mu[(size*x)+i], zeff, ModIndex, xstar)
                        gamma_complex.append(gamma_complex_temp2)
                    else:
                        gamma_complex_temp=Dispersion(nu[(size*x)+i], eta[(size*x)+i], shat[(size*x)+i], beta[(size*x)+i], ky[(size*x)+i], mu[(size*x)+i], zeff, ModIndex, xstar)
                        gamma_complex.append(gamma_complex_temp)
                for i in range(m):
                    gamma_complex_temp1=Dispersion(nu[(size*n)+i], eta[(size*n)+i], shat[(size*n)+i], beta[(size*n)+i], ky[(size*n)+i], mu[(size*n)+i], zeff, ModIndex, xstar)
                    gamma_complex.append(gamma_complex_temp1)
                    
                    #above else block for a nontrivial case where # of rows > # of processors to keep some degree of efficiency. Not optimal unless m==0.
          
    gamma_complex=np.asarray(gamma_complex)
    #factor=np.asarray(factor)
    gamma=gamma_complex.imag
    omega=gamma_complex.real

    return gamma,omega


    gamma,omega=Dispersion_calc(filename)
