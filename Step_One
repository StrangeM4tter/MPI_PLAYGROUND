import atexit
from time import time, strftime, localtime
from datetime import timedelta

def secondsToStr(elapsed=None):
    if elapsed is None:
        return strftime("%Y-%m-%d %H:%M:%S", localtime())
    else:
        return str(timedelta(seconds=elapsed))

def log(s, elapsed=None):
    line = "="*40
    print(line)
    print(secondsToStr(), '-', s)
    if elapsed:
        print("Elapsed time:", elapsed)
    print(line)
    print()

def endlog():
    end = time()
    elapsed = end-start
    log("End Program", secondsToStr(elapsed))

start = time()
atexit.register(endlog)
log("Start Program")

import pandas as pd
import numpy as np
from mpi4py import MPI
comm = MPI.COMM_WORLD
rank = comm.Get_rank()
from DispersionRelationDeterminantFullConductivityZeff import Dispersion
#VERSION 1 run the following: srun -N 1 -n 10 -o 1 -t 02:00:00 -p development -J GKIMP time ibrun python3 ./<file>.py

filename='MTM_dispersion_n_scanp169509.04218_465'


def Dispersion_calc(filename):
    rank    
    gamma_complex_temp=0                   
    gamma_complex=[]  
    data=pd.read_csv(filename+'.csv')  	#data is a dataframe.                          #code will run on all procs unless specified, careful.       
 
    nu=data['nu']
    nx=len(nu)
    zeff=data['zeff'][0]
  
    eta=data['eta']

    shat=data['shat']

    beta=data['beta']
  
    ky=data['ky']
    
    mu=data['mu']
   
    xstar=data['xstar'][0]
    
    ModIndex=data['ModIndex'][0]
     
    ##if rank == 0:                               #more of a test than anything. Causes clutter, off by default.
        ##for i in range(nx):          
            ##print(nu, eta, shat, beta, ky, mu, zeff, ModIndex, xstar)
            
    if size >= nx:        
        for i in range(nx):
            if rank == i:     
                gamma_complex_temp=Dispersion(nu[i], zeff, eta[i], beta[i], ky[i], ModIndex,  mu[i],  xstar, shat[i]) 
                gamma_complex.append(gamma_complex_temp)
    else:
        for i in range(size):
            if (rank) == i:
                m = nx%size             #remainder
                n = nx//size            #number of times size can fit evenly into nx
                for x in range(n):
                    if x == 0:
                        gamma_complex_temp2=Dispersion(nu[(size*x)+i], zeff, eta[(size*x)+i], beta[(size*x)+i], ky[(size*x)+i], ModIndex,  mu[(size*x)+i], xstar, shat[(size*x)+i])
                        gamma_complex.append(gamma_complex_temp2)
                    else:
                        gamma_complex_temp=Dispersion(nu[(size*x)+i], zeff, eta[(size*x)+i], beta[(size*x)+i], ky[(size*x)+i], ModIndex, mu[(size*x)+i],  xstar, shat[(size*x)+i])
                        gamma_complex.append(gamma_complex_temp)
                for i in range(m):
                    gamma_complex_temp1=Dispersion(nu[(size*n)+i], zeff, eta[(size*n)+i], beta[(size*n)+i], ky[(size*n)+i], ModIndex,  mu[(size*n)+i],  xstar, shat[(size*n)+i])
                    gamma_complex.append(gamma_complex_temp1)
                    
                    #above else block for a nontrivial case where # of rows > # of processors to keep some degree of efficiency. Not optimal unless m==0.
          
    gamma_complex=np.asarray(gamma_complex)
    #factor=np.asarray(factor)
    gamma=gamma_complex.imag
    omega=gamma_complex.real

    return gamma,omega


    gamma,omega=Dispersion_calc(filename)
